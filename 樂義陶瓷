<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Èô∂ËóùÂ§ßÂ∏´ - 3D Êâã‰ΩúÈô∂Áì∑</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Noto Sans TC', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; cursor: crosshair; }
        .ui-panel {
            position: absolute;
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        /* Mobile adjustment */
        @media (max-width: 768px) {
            .controls-sidebar {
                bottom: 1rem;
                left: 1rem;
                right: 1rem;
                top: auto;
                width: auto;
                height: auto;
                flex-direction: row;
                overflow-x: auto;
                padding: 1rem;
            }
        }
    </style>
</head>
<body>

    <!-- Canvas for Three.js -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div class="absolute top-4 left-4 z-20 text-white pointer-events-none">
        <h1 class="text-3xl font-bold tracking-wider drop-shadow-lg">Èô∂ËóùÂ∑•Âùä</h1>
        <p class="text-sm opacity-80 mt-1">Êåâ‰ΩèÊªëÈº†‰∏¶ÊãñÊõ≥‰æÜÂ°ëÂΩ¢</p>
    </div>

    <!-- Controls Panel -->
    <div class="ui-panel right-4 top-4 bottom-4 w-64 p-6 flex flex-col gap-6 overflow-y-auto controls-sidebar">
        
        <!-- Shapes -->
        <div>
            <h3 class="text-gray-700 font-bold mb-3 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
                ÈÅ∏ÊìáÂü∫Â∫ï
            </h3>
            <div class="grid grid-cols-3 gap-2">
                <button onclick="resetShape('cylinder')" class="p-2 bg-gray-200 hover:bg-gray-300 rounded text-xs text-center transition">ÂúìÊü±</button>
                <button onclick="resetShape('vase')" class="p-2 bg-gray-200 hover:bg-gray-300 rounded text-xs text-center transition">Ëä±Áì∂</button>
                <button onclick="resetShape('bowl')" class="p-2 bg-gray-200 hover:bg-gray-300 rounded text-xs text-center transition">ÈóäÁ¢ó</button>
            </div>
        </div>

        <!-- Colors -->
        <div>
            <h3 class="text-gray-700 font-bold mb-3 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01" /></svg>
                ÈáâËâ≤ÈÅ∏Êìá
            </h3>
            <div class="grid grid-cols-4 gap-2">
                <button onclick="changeColor('#8B5A2B')" class="w-10 h-10 rounded-full bg-[#8B5A2B] border-2 border-transparent hover:border-gray-500 shadow-sm"></button>
                <button onclick="changeColor('#A0522D')" class="w-10 h-10 rounded-full bg-[#A0522D] border-2 border-transparent hover:border-gray-500 shadow-sm"></button>
                <button onclick="changeColor('#E6E6FA')" class="w-10 h-10 rounded-full bg-[#E6E6FA] border-2 border-transparent hover:border-gray-500 shadow-sm"></button>
                <button onclick="changeColor('#2F4F4F')" class="w-10 h-10 rounded-full bg-[#2F4F4F] border-2 border-transparent hover:border-gray-500 shadow-sm"></button>
                <button onclick="changeColor('#4682B4')" class="w-10 h-10 rounded-full bg-[#4682B4] border-2 border-transparent hover:border-gray-500 shadow-sm"></button>
                <button onclick="changeColor('#556B2F')" class="w-10 h-10 rounded-full bg-[#556B2F] border-2 border-transparent hover:border-gray-500 shadow-sm"></button>
                <button onclick="changeColor('#800000')" class="w-10 h-10 rounded-full bg-[#800000] border-2 border-transparent hover:border-gray-500 shadow-sm"></button>
                <button onclick="changeColor('#1a1a1a')" class="w-10 h-10 rounded-full bg-gray-900 border-2 border-transparent hover:border-gray-500 shadow-sm"></button>
            </div>
        </div>

        <!-- Material -->
        <div>
            <h3 class="text-gray-700 font-bold mb-3">Ë≥™ÊÑü</h3>
            <div class="flex gap-2">
                <button onclick="setGlossiness(0.1, 0.9)" class="flex-1 py-2 px-3 bg-gray-100 hover:bg-gray-200 rounded text-xs font-medium transition text-gray-800">ÈúßÈù¢Èô∂Âúü</button>
                <button onclick="setGlossiness(0.8, 0.1)" class="flex-1 py-2 px-3 bg-blue-50 hover:bg-blue-100 rounded text-xs font-medium transition text-blue-800 border border-blue-200">‰∫ÆÈù¢ÊñΩÈáâ</button>
            </div>
        </div>

        <!-- Actions -->
        <div class="mt-auto pt-4 border-t border-gray-200">
            <button onclick="exportImage()" class="w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold shadow-md transition transform active:scale-95 mb-2">
                üì∏ ÊãçÁÖßÁïôÂøµ
            </button>
            <button onclick="resetShape(currentShapeType)" class="w-full py-2 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-lg text-sm transition">
                ÈáçÁΩÆÁï∂ÂâçÂΩ¢ÁãÄ
            </button>
        </div>
    </div>

    <!-- Visual Indicator for Interaction -->
    <div id="hand-guide" class="fixed pointer-events-none hidden border-2 border-white/50 rounded-full transform -translate-x-1/2 -translate-y-1/2 shadow-[0_0_15px_rgba(255,255,255,0.5)] z-0 mix-blend-overlay transition-all duration-75"></div>

    <script>
        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.Fog(0x1a1a1a, 20, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 25);
        camera.lookAt(0, 5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
        mainLight.position.set(10, 10, 10);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 1024;
        mainLight.shadow.mapSize.height = 1024;
        scene.add(mainLight);

        const backLight = new THREE.PointLight(0x4455ff, 1);
        backLight.position.set(-10, 5, -10);
        scene.add(backLight);

        const rimLight = new THREE.SpotLight(0xffaa55, 2);
        rimLight.position.set(0, 20, 0);
        rimLight.lookAt(0, 0, 0);
        rimLight.penumbra = 0.5;
        scene.add(rimLight);

        // --- POTTERY LOGIC ---
        let geometry, material, mesh;
        let points = [];
        const numPoints = 50; // Vertical resolution
        const height = 12;
        const radialSegments = 64;
        let currentShapeType = 'cylinder';

        // Base plate (The wheel)
        const wheelGeo = new THREE.CylinderGeometry(9, 10, 1, 64);
        const wheelMat = new THREE.MeshStandardMaterial({ 
            color: 0x333333, 
            roughness: 0.8, 
            metalness: 0.5 
        });
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.position.y = -0.5;
        wheel.receiveShadow = true;
        scene.add(wheel);

        // Initial Material (Clay)
        material = new THREE.MeshPhysicalMaterial({
            color: 0x8B5A2B,
            metalness: 0.0,
            roughness: 0.1, // Wet clay look
            clearcoat: 0.5,
            clearcoatRoughness: 0.1,
            side: THREE.DoubleSide,
            flatShading: false
        });

        function createProfile(type) {
            points = [];
            for (let i = 0; i < numPoints; i++) {
                const y = (i / (numPoints - 1)) * height;
                let x = 3; // Default radius

                if (type === 'cylinder') {
                    x = 3;
                } else if (type === 'vase') {
                    // Sine wave function for vase shape
                    x = 3 + Math.sin(y * 0.8) * 1.5 - (y * 0.1); 
                    if (x < 1) x = 1;
                } else if (type === 'bowl') {
                    // Parabolic curve
                    const t = i / (numPoints - 1);
                    x = 2 + (t * 6);
                }
                points.push(new THREE.Vector2(x, y));
            }
        }

        function updateGeometry() {
            if (mesh) {
                scene.remove(mesh);
                geometry.dispose();
            }
            geometry = new THREE.LatheGeometry(points, radialSegments);
            // Fix normals for lighting
            geometry.computeVertexNormals();
            
            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
        }

        // Initialize
        createProfile('cylinder');
        updateGeometry();

        // --- INTERACTION LOGIC ---
        let isDragging = false;
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Logic plane facing camera
        
        // Visual Guide Helper
        const guideDiv = document.getElementById('hand-guide');

        // Helper to map mouse to 3D world coordinates at pottery depth
        function getInteractPosition(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // We want to intersect with a virtual plane at x=0 (center of rotation)
            // But visually, the user touches the "edge" of the pot.
            // Let's create a plane that faces the camera but sits at Z=0
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(new THREE.Plane(new THREE.Vector3(0, 0, 1), 0), target);
            return target;
        }

        function onStart(e) {
            if (e.target.closest('.ui-panel')) return;
            isDragging = true;
            handleInteraction(e);
        }

        function onEnd() {
            isDragging = false;
            guideDiv.classList.add('hidden');
        }

        function onMove(e) {
            if (!isDragging) return;
            handleInteraction(e);
        }

        function handleInteraction(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const worldPos = getInteractPosition(clientX, clientY);

            // 1. Determine Height (Y)
            // 2. Determine Radius (Distance from center X=0, Z=0) -> Just use abs(worldPos.x) approx
            
            const targetY = Math.max(0, Math.min(height, worldPos.y));
            // Calculate distance from center axis as the desired radius
            // User intention: moving mouse right pulls clay out, left pushes in
            // But to keep it intuitive: Mouse X position determines absolute radius
            const targetRadius = Math.abs(worldPos.x);

            // Apply deformation
            deformMesh(targetY, targetRadius);

            // Update UI Guide
            guideDiv.classList.remove('hidden');
            guideDiv.style.left = clientX + 'px';
            guideDiv.style.top = clientY + 'px';
            guideDiv.style.width = (Math.abs(worldPos.x) * 40) + 'px'; // Scale visual
            guideDiv.style.height = (Math.abs(worldPos.x) * 10) + 'px';
        }

        function deformMesh(targetY, targetRadius) {
            // Find closest points in profile
            // Convert targetY to index space
            const indexFloat = (targetY / height) * (numPoints - 1);
            
            // Influence range (Gaussian bell curve effect)
            const range = 6; // How many points up/down are affected

            for (let i = 0; i < numPoints; i++) {
                const dist = Math.abs(i - indexFloat);
                if (dist < range) {
                    // Falloff factor (1 at center, 0 at edge of range)
                    const falloff = 0.5 * (1 + Math.cos(Math.PI * dist / range));
                    
                    // Smoothly blend current radius towards target radius
                    // We don't snap instantly, we lerp for a "clay" feel
                    const lerpFactor = 0.15; 
                    
                    let newRadius = points[i].x + (targetRadius - points[i].x) * falloff * lerpFactor;
                    
                    // Constraints
                    if (newRadius < 0.5) newRadius = 0.5; // Minimum thickness
                    if (newRadius > 8) newRadius = 8;     // Max width
                    
                    points[i].setX(newRadius);
                }
            }
            updateGeometry();
        }

        // Event Listeners
        window.addEventListener('mousedown', onStart);
        window.addEventListener('mouseup', onEnd);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('touchstart', onStart, {passive: false});
        window.addEventListener('touchend', onEnd);
        window.addEventListener('touchmove', (e) => { e.preventDefault(); onMove(e); }, {passive: false});

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate the pottery and the wheel
            const rotSpeed = 0.02;
            if (mesh) mesh.rotation.y -= rotSpeed;
            if (wheel) wheel.rotation.y -= rotSpeed;

            renderer.render(scene, camera);
        }
        animate();

        // --- UI FUNCTIONS ---

        window.resetShape = function(type) {
            currentShapeType = type;
            createProfile(type);
            updateGeometry();
        };

        window.changeColor = function(colorStr) {
            material.color.set(colorStr);
        };

        window.setGlossiness = function(roughness, clearcoat) {
            material.roughness = roughness;
            material.clearcoat = clearcoat;
            // Adjust clearcoat roughness inversely usually
            material.clearcoatRoughness = roughness * 0.5;
        };

        window.exportImage = function() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'my_pottery.png';
            link.href = dataURL;
            link.click();
        };

    </script>
</body>
</html>
